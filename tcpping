#!/bin/sh
#
# tcpping: test response times using TCP SYN packets
#          URL: http://www.vdberg.org/~richard/tcpping.html
#
# uses recent versions of traceroute supporting TCP sessions
#
# (c) 2002-2005 Richard van den Berg <richard@vdberg.org> under the GPL
#               http://www.gnu.org/copyleft/gpl.html
#
# 2002/12/20 v1.0 initial version
# 2003/01/25 v1.1 added -c and -r options
#                 now accepting all other tcptraceroute options
# 2003/01/30 v1.2 removed double quotes around backquotes
# 2003/03/25 v1.3 added -x option, courtesy of Alvin Austin <alvin@crlogic.com>
# 2005/03/31 v1.4 added -C option, courtesy of Norman Rasmussen <norman@rasmussen.org>
# 2007/01/11 v1.5 catch bad destination addresses
# 2007/01/19 v1.6 catch non-root tcptraceroute
# 2008/02/10 v1.7 make -C work when reverse lookup fails, courtesy of Fabrice Le Dorze <Fabrice.LeDorze@apx.fr>
# 2010/06/04 v1.8 make -C work when ipaddress doesn't reply, courtesy of Yann Beulque
# 2018/04/25 v2.0 make tcpping work with recent traceroute binary (tested with version 2.0.22)
#                 added language agonstic traceroute support
#                 drop tcptraceroute prerequisite
#                 added support for other ttl than 255
#                 added -z debug parameter which shows what is actually sent to traceroute
#                 removed elder options (-l, -p which is defined as ending optional argument)
#                 multiple small improvements (local variables, better readability)
#                 courtesy of Orsiris de Jong <ozy@netpower.fr>

_DEBUG=false
ver="v2.0-dev"
format="%Y%m%d%H%M%S"
d="no"
c="no"
C="no"
f_ttl=255
m_ttl=255
seq=0
numberOfQueries=1
repeatWaitTime=1
timeToWait=3
topts=""

# Make sure traceroute output is language agnostic
export LANG=C

usage () {
	name=`basename $0`
	echo "tcpping $ver Richard van den Berg <richard@vdberg.org>"
	echo
	echo "Usage: $name [-d] [-c] [-C] [-w sec] [-q num] [-x count] ipaddress [port]"
	echo
	echo "        -d            print timestamp before every result"
	echo "        -c            print a columned result line"
	echo "        -C            print in the same format as fping's -C option"
	echo "        -w            wait time in seconds (defaults to 3)"
	echo "        -r            repeat every n seconds (defaults to 1)"
	echo "        -x            repeat n times (defaults to unlimited)"
	echo "        -f            first ttl (defaults to 255), see traceroute man"
	echo "        -m            max ttl (defaults to 255), see traceroute man"
	echo "        -nNFASEisfm   see traceroute man"
	echo "        --sport       define source port, see traceroute man"
	echo "        -z            show what command is actually sent to traceroute (debug)"
	echo
	echo "Default port is 80"
	echo "See also: man traceroute"
	echo
}

# Check if site can be reached via TCP SYN
_checksite() {
	local host="${1}"
	local port="${2:-80}"
	local args="${@: -1:1}"
	local traceRoute
	local traceRouteCommand

	traceRouteCommand="traceroute -T -f ${f_ttl} -m ${m_ttl} -q ${numberOfQueries} -w ${timeToWait} -p ${port} ${host}"
	if [ $_DEBUG == true ]; then
		echo "$traceRouteCommand"
	fi
	traceRoute=`$traceRouteCommand 2>&1`

	if echo "${traceRoute}" | egrep -i "(bad destination|got roo|not known|cannot handle)" >/dev/null 2>&1; then
		echo "${traceRoute}"
		exit 1
	fi
}

# Measure latency via TCP SYN
_testsite() {
	local host="${1}"
	local port="${2:-80}"
	local myseq="${3}"

	shift
	[ "${c}" = "yes" ] && nows=`date +${format}`
	[ "${d}" = "yes" ] && nowd=`date`

	local traceRoute
	local traceRouteCommand
	local foundHost
	local rtt

	# Remove first line from result
	traceRouteCommand="traceroute -T -f ${f_ttl} -m ${m_ttl} -q ${numberOfQueries} -w ${timeToWait} -p ${port} ${host}"
	if [ $_DEBUG == true ]; then
		echo "$traceRouteCommand"
	fi
	traceRoute=`$traceRouteCommand | awk '{if (NR!=1) {print}}' 2>/dev/null`
	foundHost=`echo "${traceRoute}" | awk '{print $2" "$3}'`

	if [ "$foundHost" != "" ] && [ "$foundHost" != "* " ]; then
		host="$foundHost"
	fi

	rtt=`echo "${traceRoute}" | awk '{print $4}'`
	#TODO: add not variable (and rename it to be understandable)

	[ "${d}" = "yes" ] && echo "$nowd"
	if [ "${c}" = "yes" ]; then
		if [ "x${rtt}" != "x" -a "x${not}" = "x" ]; then
			echo "$myseq $nows $rtt $host"
		else
			echo "$myseq $nows $max $host"
		fi
	elif [ "${C}" = "yes" ]; then
		if [ "$myseq" = "0" ]; then
			echo -n "$host :"
		fi
		if [ "x${rtt}" != "x" -a "x${not}" = "x" ]; then
			if [ $rtt != "255" ]; then
				echo -n " $rtt"
			else
				echo -n " -"
			fi
		else
			echo -n " -"
		fi
		if [ "$x" = "1" ]; then
			echo
		fi
	else
		echo "${traceRoute}" | sed -e "s/^.*\*.*$/seq $myseq: no response (timeout)/" -e "s/^$ttl /seq $myseq: tcp response from/"
	fi
}

while getopts dhzq:w:cr:nNFSAEi:f:l:m:p:s:x:C opt ; do
	case "$opt" in
		d|c|C) eval $opt="yes" ;;
		q|w|r|x) eval $opt="$OPTARG" ;;
		n|N|F|S|A|E) topt="$topt -$opt" ;;
		i|s) topt="$topt -$opt $OPTARG" ;;
		f) f_ttl="$OPTARG" ;;
		m) m_ttl="$OPTARG" ;;
		z) _DEBUG=true ;;
		?) usage; exit ;;
	esac
done

shift `expr $OPTIND - 1`

if [ "x$1" = "x" ]; then
	usage
	exit
fi

max=`echo "${timeToWait} * 1000" | bc`

if [ `date +%s` != "%s" ]; then
	format="%s"
fi

# Since port argument is not mandatory, we want do determine whether it was given or not
beforeLastArg="${@: -2:1}"
lastArg="${@: -1:1}"

case $lastArg in
	''|*[!0-9]*)
	# Last argument is not numeric, assuming it's an FQDN or IP
	host=$lastArg
	;;
	*)
	# Last argument is numeric, assuming it's a port number
	host=$beforeLastArg
	port=$lastArg
	;;
esac

_checksite "${host}" "${port}" ${topt}

if [ "$x" = "" ]; then
	while [ true ] ; do
		_testsite "${host}" "${port}" ${seq} ${topt} &
		pid=$!
		if [ "${C}" = "yes" ]; then
			wait $pid
		fi
		seq=`expr $seq + 1`
		if [ $seq -gt 0 ]; then
			_DEBUG=false
		fi
		sleep ${repeatWaitTime}
	done
else
	while [ "$x" -gt 0 ] ; do
		_testsite "${host}" "${port}" ${seq} ${topt} &
		pid=$!
		if [ "${C}" = "yes" ]; then
			wait $pid
		fi
		seq=`expr $seq + 1`
		if [ $seq -gt 0 ]; then
			_DEBUG=false
		fi
		x=`expr $x - 1`
		if [ "$x" -gt 0 ]; then
			sleep ${repeatWaitTime}
		fi
	done
fi

exit
