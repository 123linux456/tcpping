#!/bin/sh
#
# tcpping: test response times using TCP SYN packets
#          URL: http://www.vdberg.org/~richard/tcpping.html
#
# uses tcptraceroute from http://michael.toren.net/code/tcptraceroute/
#
# (c) 2002-2005 Richard van den Berg <richard@vdberg.org> under the GPL
#               http://www.gnu.org/copyleft/gpl.html
#
# 2002/12/20 v1.0 initial version
# 2003/01/25 v1.1 added -c and -r options
#                 now accepting all other tcptraceroute options
# 2003/01/30 v1.2 removed double quotes around backquotes
# 2003/03/25 v1.3 added -x option, courtesy of Alvin Austin <alvin@crlogic.com>
# 2005/03/31 v1.4 added -C option, courtesy of Norman Rasmussen <norman@rasmussen.org>
# 2007/01/11 v1.5 catch bad destination addresses
# 2007/01/19 v1.6 catch non-root tcptraceroute
# 2008/02/10 v1.7 make -C work when reverse lookup fails, courtesy of Fabrice Le Dorze <Fabrice.LeDorze@apx.fr>
# 2010/06/04 v1.8 make -C work when ipaddress doesn't reply, courtesy of Yann Beulque
# 2018/04/25 v2.0 make tcpping work with recent traceroute binary (tested with version 2.0.22)
#                 drop tcptraceroute prerequisite
#                 multiple small improvements (local variables, better readability)
#                 courtesy of Orsiris de Jong <ozy@netpower.fr>

ver="v1.9"
format="%Y%m%d%H%M%S"
d="no"
c="no"
C="no"
ttl=255
seq=0
numberOfQueries=1
repeatWaitTime=1
timeToWait=3
topts=""

usage () {
        name=`basename $0`
        echo "tcpping $ver Richard van den Berg <richard@vdberg.org>"
        echo
        echo "Usage: $name [-d] [-c] [-C] [-w sec] [-q num] [-x count] ipaddress [port]"
        echo
        echo "        -d   print timestamp before every result"
        echo "        -c   print a columned result line"
        echo "        -C   print in the same format as fping's -C option"
        echo "        -w   wait time in seconds (defaults to 3)"
        echo "        -r   repeat every n seconds (defaults to 1)"
        echo "        -x   repeat n times (defaults to unlimited)"
        echo
        echo "See also: man traceroute"
        echo
}

# Check if site can be reached via TCP SYN
_checksite() {
        local host="${1}"
        local port="${2:-80}"
        local args="${@: -1:1}"
        local ttr

        ttr=`traceroute -f ${ttl} -m ${ttl} -q ${numberOfQueries} -w ${timeToWait} -p ${port} ${host} 2>&1`
        if echo "${ttr}" | egrep -i "(bad destination|got roo)" >/dev/null 2>&1; then
                echo "${ttr}"
                exit 1
        fi
}

# Measure latency via TCP SYN
_testsite() {
        local myseq="${1}"
        shift
        [ "${c}" = "yes" ] && nows=`date +${format}`
        [ "${d}" = "yes" ] && nowd=`date`

        local host="${1}"
        local port="${2:-80}"

        local ttr
        local host
        local rtt



        # Remove first line from result
        ttr=`traceroute -T -f ${ttl} -m ${ttl} -q ${numberOfQueries} -w ${timeToWait} -p ${port} ${host} | awk '{if (NR!=1) {print}}' 2>/dev/null`
        host=`echo "${ttr}" | awk '{print $2" "$3}'`
        rtt=`echo "${ttr}" | awk '{print $4}'`

        [ "${d}" = "yes" ] && echo "$nowd"
        if [ "${c}" = "yes" ]; then
                if [ "x${rtt}" != "x" -a "x${not}" = "x" ]; then
                        echo "$myseq $nows $rtt $host"
                else
                        echo "$myseq $nows $max $host"
                fi
        elif [ "${C}" = "yes" ]; then
                if [ "$myseq" = "0" ]; then
                        echo -n "$1 :"
                fi
                if [ "x${rtt}" != "x" -a "x${not}" = "x" ]; then
                        if [ $rtt != "255" ]; then
                                echo -n " $rtt"
                        else
                                echo -n " -"
                        fi
                else
                        echo -n " -"
                fi
                if [ "$x" = "1" ]; then
                        echo
                fi
        else
                echo "${ttr}" | sed -e "s/^.*\*.*$/seq $myseq: no response (timeout)/" -e "s/^$ttl /seq $myseq: tcp response from/"
        fi
#       echo "${ttr}"
}

while getopts dhq:w:cr:nNFSAEi:f:l:m:p:s:x:C opt ; do
        case "$opt" in
                d|c|C) eval $opt="yes" ;;
                q|w|r|x) eval $opt="$OPTARG" ;;
                n|N|F|S|A|E) topt="$topt -$opt" ;;
                i|l|p|s) topt="$topt -$opt $OPTARG" ;;
                f|m) ttl="$OPTARG" ;;
                ?) usage; exit ;;
        esac
done

shift `expr $OPTIND - 1`

if [ "x$1" = "x" ]; then
        usage
        exit
fi

max=`echo "${timeToWait} * 1000" | bc`

if [ `date +%s` != "%s" ]; then
        format="%s"
fi

_checksite ${topt} $*

if [ "$x" = "" ]; then
        while [ true ] ; do
                _testsite ${seq} ${topt} $* &
                pid=$!
                if [ "${C}" = "yes" ]; then
                        wait $pid
                fi
                seq=`expr $seq + 1`
                sleep ${repeatWaitTime}
        done
else
        while [ "$x" -gt 0 ] ; do
                _testsite ${seq} ${topt} $* &
                pid=$!
                if [ "${C}" = "yes" ]; then
                        wait $pid
                fi
                seq=`expr $seq + 1`
                x=`expr $x - 1`
                if [ "$x" -gt 0 ]; then
                        sleep ${repeatWaitTime}
                fi
        done
fi

exit
